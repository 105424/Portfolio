{"ts":1354710316273,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * jQuery Masonry v2.1.06\n * A dynamic layout plugin for jQuery\n * The flip-side of CSS Floats\n * http://masonry.desandro.com\n *\n * Licensed under the MIT license.\n * Copyright 2012 David DeSandro\n */\n\n/*jshint browser: true, curly: true, eqeqeq: true, forin: false, immed: false, newcap: true, noempty: true, strict: true, undef: true */\n/*global jQuery: false */\n\n(function( window, $, undefined ){\n\n  'use strict';\n\n  /*\n   * smartresize: debounced resize event for jQuery\n   *\n   * latest version and complete README available on Github:\n   * https://github.com/louisremi/jquery.smartresize.js\n   *\n   * Copyright 2011 @louis_remi\n   * Licensed under the MIT license.\n   */\n\n  var $event = $.event,\n      resizeTimeout;\n\n  $event.special.smartresize = {\n    setup: function() {\n      $(this).bind( \"resize\", $event.special.smartresize.handler );\n    },\n    teardown: function() {\n      $(this).unbind( \"resize\", $event.special.smartresize.handler );\n    },\n    handler: function( event, execAsap ) {\n      // Save the context\n      var context = this,\n          args = arguments;\n\n      // set correct event type\n      event.type = \"smartresize\";\n\n      if ( resizeTimeout ) { clearTimeout( resizeTimeout ); }\n      resizeTimeout = setTimeout(function() {\n        $.event.handle.apply( context, args );\n      }, execAsap === \"execAsap\"? 0 : 100 );\n    }\n  };\n\n  $.fn.smartresize = function( fn ) {\n    return fn ? this.bind( \"smartresize\", fn ) : this.trigger( \"smartresize\", [\"execAsap\"] );\n  };\n\n\n\n// ========================= Masonry ===============================\n\n\n  // our \"Widget\" object constructor\n  $.Mason = function( options, element ){\n    this.element = $( element );\n\n    this._create( options );\n    this._init();\n  };\n\n  $.Mason.settings = {\n    isResizable: true,\n    isAnimated: false,\n    animationOptions: {\n      queue: false,\n      duration: 500\n    },\n    gutterWidth: 0,\n    isRTL: false,\n    isFitWidth: false,\n    containerStyle: {\n      position: 'relative'\n    }\n  };\n\n  $.Mason.prototype = {\n\n    _filterFindBricks: function( $elems ) {\n      var selector = this.options.itemSelector;\n      // if there is a selector\n      // filter/find appropriate item elements\n      return !selector ? $elems : $elems.filter( selector ).add( $elems.find( selector ) );\n    },\n\n    _getBricks: function( $elems ) {\n      var $bricks = this._filterFindBricks( $elems )\n        .css({ position: 'absolute' })\n        .addClass('masonry-brick');\n      return $bricks;\n    },\n    \n    // sets up widget\n    _create : function( options ) {\n      \n      this.options = $.extend( true, {}, $.Mason.settings, options );\n      this.styleQueue = [];\n\n      // get original styles in case we re-apply them in .destroy()\n      var elemStyle = this.element[0].style;\n      this.originalStyle = {\n        // get height\n        height: elemStyle.height || ''\n      };\n      // get other styles that will be overwritten\n      var containerStyle = this.options.containerStyle;\n      for ( var prop in containerStyle ) {\n        this.originalStyle[ prop ] = elemStyle[ prop ] || '';\n      }\n\n      this.element.css( containerStyle );\n\n      this.horizontalDirection = this.options.isRTL ? 'right' : 'left';\n\n      var x = this.element.css( 'padding-' + this.horizontalDirection );\n      var y = this.element.css( 'padding-top' );\n      this.offset = {\n        x: x ? parseInt( x, 10 ) : 0,\n        y: y ? parseInt( y, 10 ) : 0\n      };\n      \n      this.isFluid = this.options.columnWidth && typeof this.options.columnWidth === 'function';\n\n      // add masonry class first time around\n      var instance = this;\n      setTimeout( function() {\n        instance.element.addClass('masonry');\n      }, 0 );\n      \n      // bind resize method\n      if ( this.options.isResizable ) {\n        $(window).bind( 'smartresize.masonry', function() { \n          instance.resize();\n        });\n      }\n\n\n      // need to get bricks\n      this.reloadItems();\n\n    },\n  \n    // _init fires when instance is first created\n    // and when instance is triggered again -> $el.masonry();\n    _init : function( callback ) {\n      this._getColumns();\n      this._reLayout( callback );\n    },\n\n    option: function( key, value ){\n      // set options AFTER initialization:\n      // signature: $('#foo').bar({ cool:false });\n      if ( $.isPlainObject( key ) ){\n        this.options = $.extend(true, this.options, key);\n      } \n    },\n    \n    // ====================== General Layout ======================\n\n    // used on collection of atoms (should be filtered, and sorted before )\n    // accepts atoms-to-be-laid-out to start with\n    layout : function( $bricks, callback ) {\n\n      // place each brick\n      for (var i=0, len = $bricks.length; i < len; i++) {\n        this._placeBrick( $bricks[i] );\n      }\n      \n      // set the size of the container\n      var containerSize = {};\n      containerSize.height = Math.max.apply( Math, this.colYs );\n      if ( this.options.isFitWidth ) {\n        var unusedCols = 0;\n        i = this.cols;\n        // count unused columns\n        while ( --i ) {\n          if ( this.colYs[i] !== 0 ) {\n            break;\n          }\n          unusedCols++;\n        }\n        // fit container to columns that have been used;\n        containerSize.width = (this.cols - unusedCols) * this.columnWidth - this.options.gutterWidth;\n      }\n      this.styleQueue.push({ $el: this.element, style: containerSize });\n\n      // are we animating the layout arrangement?\n      // use plugin-ish syntax for css or animate\n      var styleFn = !this.isLaidOut ? 'css' : (\n            this.options.isAnimated ? 'animate' : 'css'\n          ),\n          animOpts = this.options.animationOptions;\n\n      // process styleQueue\n      var obj;\n      for (i=0, len = this.styleQueue.length; i < len; i++) {\n        obj = this.styleQueue[i];\n        obj.$el[ styleFn ]( obj.style, animOpts );\n      }\n\n      // clear out queue for next time\n      this.styleQueue = [];\n\n      // provide $elems as context for the callback\n      if ( callback ) {\n        callback.call( $bricks );\n      }\n      \n      this.isLaidOut = true;\n    },\n    \n    // calculates number of columns\n    // i.e. this.columnWidth = 200\n    _getColumns : function() {\n      var container = this.options.isFitWidth ? this.element.parent() : this.element,\n          containerWidth = container.width();\n\n                         // use fluid columnWidth function if there\n      this.columnWidth = this.isFluid ? this.options.columnWidth( containerWidth ) :\n                    // if not, how about the explicitly set option?\n                    this.options.columnWidth ||\n                    // or use the size of the first item\n                    this.$bricks.outerWidth(true) ||\n                    // if there's no items, use size of container\n                    containerWidth;\n\n      this.columnWidth += this.options.gutterWidth;\n\n      this.cols = Math.floor( ( containerWidth + this.options.gutterWidth ) / this.columnWidth );\n      this.cols = Math.max( this.cols, 1 );\n\n    },\n\n    // layout logic\n    _placeBrick: function( brick ) {\n      var $brick = $(brick),\n          colSpan, groupCount, groupY, groupColY, j;\n\n      //how many columns does this brick span\n      colSpan = Math.ceil( $brick.outerWidth(true) / this.columnWidth );\n      colSpan = Math.min( colSpan, this.cols );\n\n      if ( colSpan === 1 ) {\n        // if brick spans only one column, just like singleMode\n        groupY = this.colYs;\n      } else {\n        // brick spans more than one column\n        // how many different places could this brick fit horizontally\n        groupCount = this.cols + 1 - colSpan;\n        groupY = [];\n\n        // for each group potential horizontal position\n        for ( j=0; j < groupCount; j++ ) {\n          // make an array of colY values for that one group\n          groupColY = this.colYs.slice( j, j+colSpan );\n          // and get the max value of the array\n          groupY[j] = Math.max.apply( Math, groupColY );\n        }\n\n      }\n\n      // get the minimum Y value from the columns\n      var minimumY = Math.min.apply( Math, groupY ),\n          shortCol = 0;\n      \n      // Find index of short column, the first from the left\n      for (var i=0, len = groupY.length; i < len; i++) {\n        if ( groupY[i] === minimumY ) {\n          shortCol = i;\n          break;\n        }\n      }\n\n      // position the brick\n      var position = {\n        top: minimumY + this.offset.y\n      };\n      // position.left or position.right\n      position[ this.horizontalDirection ] = this.columnWidth * shortCol + this.offset.x;\n      this.styleQueue.push({ $el: $brick, style: position });\n\n      // apply setHeight to necessary columns\n      var setHeight = minimumY + $brick.outerHeight(true),\n          setSpan = this.cols + 1 - len;\n      for ( i=0; i < setSpan; i++ ) {\n        this.colYs[ shortCol + i ] = setHeight;\n      }\n\n    },\n    \n    \n    resize: function() {\n      var prevColCount = this.cols;\n      // get updated colCount\n      this._getColumns();\n      if ( this.isFluid || this.cols !== prevColCount ) {\n        // if column count has changed, trigger new layout\n        this._reLayout();\n      }\n    },\n    \n    \n    _reLayout : function( callback ) {\n      // reset columns\n      var i = this.cols;\n      this.colYs = [];\n      while (i--) {\n        this.colYs.push( 0 );\n      }\n      // apply layout logic to all bricks\n      this.layout( this.$bricks, callback );\n    },\n    \n    // ====================== Convenience methods ======================\n    \n    // goes through all children again and gets bricks in proper order\n    reloadItems : function() {\n      this.$bricks = this._getBricks( this.element.children() );\n    },\n    \n    \n    reload : function( callback ) {\n      this.reloadItems();\n      this._init( callback );\n    },\n    \n\n    // convienence method for working with Infinite Scroll\n    appended : function( $content, isAnimatedFromBottom, callback ) {\n      if ( isAnimatedFromBottom ) {\n        // set new stuff to the bottom\n        this._filterFindBricks( $content ).css({ top: this.element.height() });\n        var instance = this;\n        setTimeout( function(){\n          instance._appended( $content, callback );\n        }, 1 );\n      } else {\n        this._appended( $content, callback );\n      }\n    },\n    \n    _appended : function( $content, callback ) {\n      var $newBricks = this._getBricks( $content );\n      // add new bricks to brick pool\n      this.$bricks = this.$bricks.add( $newBricks );\n      this.layout( $newBricks, callback );\n    },\n    \n    // removes elements from Masonry widget\n    remove : function( $content ) {\n      this.$bricks = this.$bricks.not( $content );\n      $content.remove();\n    },\n    \n    // destroys widget, returns elements and container back (close) to original style\n    destroy : function() {\n\n      this.$bricks\n        .removeClass('masonry-brick')\n        .each(function(){\n          this.style.position = '';\n          this.style.top = '';\n          this.style.left = '';\n        });\n      \n      // re-apply saved container styles\n      var elemStyle = this.element[0].style;\n      for ( var prop in this.originalStyle ) {\n        elemStyle[ prop ] = this.originalStyle[ prop ];\n      }\n\n      this.element\n        .unbind('.masonry')\n        .removeClass('masonry')\n        .removeData('masonry');\n      \n      $(window).unbind('.masonry');\n\n    }\n    \n  };\n  \n  \n  // ======================= imagesLoaded Plugin ===============================\n  /*!\n   * jQuery imagesLoaded plugin v1.1.0\n   * http://github.com/desandro/imagesloaded\n   *\n   * MIT License. by Paul Irish et al.\n   */\n\n\n  // $('#my-container').imagesLoaded(myFunction)\n  // or\n  // $('img').imagesLoaded(myFunction)\n\n  // execute a callback when all images have loaded.\n  // needed because .load() doesn't work on cached images\n\n  // callback function gets image collection as argument\n  //  `this` is the container\n\n  $.fn.imagesLoaded = function( callback ) {\n    var $this = this,\n        $images = $this.find('img').add( $this.filter('img') ),\n        len = $images.length,\n        blank = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==',\n        loaded = [];\n\n    function triggerCallback() {\n      callback.call( $this, $images );\n    }\n\n    function imgLoaded( event ) {\n      var img = event.target;\n      if ( img.src !== blank && $.inArray( img, loaded ) === -1 ){\n        loaded.push( img );\n        if ( --len <= 0 ){\n          setTimeout( triggerCallback );\n          $images.unbind( '.imagesLoaded', imgLoaded );\n        }\n      }\n    }\n\n    // if no images, trigger immediately\n    if ( !len ) {\n      triggerCallback();\n    }\n\n    $images.bind( 'load.imagesLoaded error.imagesLoaded',  imgLoaded ).each( function() {\n      // cached images don't fire load sometimes, so we reset src.\n      var src = this.src;\n      // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f\n      // data uri bypasses webkit log warning (thx doug jones)\n      this.src = blank;\n      this.src = src;\n    });\n\n    return $this;\n  };\n\n\n  // helper function for logging errors\n  // $.error breaks jQuery chaining\n  var logError = function( message ) {\n    if ( window.console ) {\n      window.console.error( message );\n    }\n  };\n  \n  // =======================  Plugin bridge  ===============================\n  // leverages data method to either create or return $.Mason constructor\n  // A bit from jQuery UI\n  //   https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js\n  // A bit from jcarousel \n  //   https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js\n\n  $.fn.masonry = function( options ) {\n    if ( typeof options === 'string' ) {\n      // call method\n      var args = Array.prototype.slice.call( arguments, 1 );\n\n      this.each(function(){\n        var instance = $.data( this, 'masonry' );\n        if ( !instance ) {\n          logError( \"cannot call methods on masonry prior to initialization; \" +\n            \"attempted to call method '\" + options + \"'\" );\n          return;\n        }\n        if ( !$.isFunction( instance[options] ) || options.charAt(0) === \"_\" ) {\n          logError( \"no such method '\" + options + \"' for masonry instance\" );\n          return;\n        }\n        // apply method\n        instance[ options ].apply( instance, args );\n      });\n    } else {\n      this.each(function() {\n        var instance = $.data( this, 'masonry' );\n        if ( instance ) {\n          // apply options & init\n          instance.option( options || {} );\n          instance._init();\n        } else {\n          // initialize new instance\n          $.data( this, 'masonry', new $.Mason( options, this ) );\n        }\n      });\n    }\n    return this;\n  };\n\n})( window, jQuery );"]],"start1":0,"start2":0,"length1":0,"length2":14828}]],"length":14828}
